/*
  This code transforms the particles position to concentration field
  defined in a square lattice. This field is passed to the code
  HydroGrid.

  The concentration in a cell of volume (dx*dy)  is defined as 
  c = number_of_particles_inside_cell / (dx*dy);

  Therefore the average concentration in the system is
  c_avg = total_number_of_particles / (lx*ly)

  where (lx*ly) is the (2D-) volume of the system.

  HOW TO COMPILE:
  1. Compile code HydroGrid.
  1. Use Makefile in fluam/tools/ to compile this code.

  HOW TO USE:
  1. Edit (if necessary) the input file hydroGridOptions.nml used by
     HydroGrid.
  2. Run the command
     spectra.exe run.particles outputname lx ly mx my nsteps sample [Npout] [Npin] [savefreq]

  with
  run.particles = file with the particles positions generated by fluam
  outputname = prefix for the output file. 
  lx = system's length along the x-axis
  ly = system's length along the y-axis
  mx = number of cells along the x-axis          
  my = number of cells along the y-axis
  nsteps = How many configurations to read from the file
  sample = analyze data only 1 of every "sample" steps.
  Npout = (default all particles) which particle to stop reading at
  Npin = (default 1) which particle to start reading from
  savefreq = (default -1) save data every savefreq. If savefreq=-1
             save data only at the end.
*/

#include <stdlib.h> 
#include <sstream>
#include <iostream>
#include <fstream>
#include "visit_writer.h"
#include "visit_writer.c"
using namespace std;

bool callHydroGrid(const int option,
                   const string outputname,
                   double *c,
                   double *density,
                   const double *y_avg,
                   const int mx,
                   const int my,
                   const double lx,
                   const double ly,
                   const double dt,
                   const int samplefreq,
                   const int step);

int main(int argc, char* argv[]){
  // Command line options
  ifstream fileinput(argv[1]);
  string outputname = argv[2];
  double lx = atof(argv[3]);
  double ly = atof(argv[4]);
  double ly_green_fraction = 1.0 / 6.0; // Green in the middle, red in the rest
  int mx = atoi(argv[5]);
  int my = atoi(argv[6]);
  int nsteps = atoi(argv[7]);
  int sample = atoi(argv[8]);
  double dt = atof(argv[9]);
  int Npout = 0, Npin = 0, savefreq = -1;
  if(argc > 10) Npout = atoi(argv[10]);
  if(argc > 11) Npin = atoi(argv[11]);
  if(argc > 12) savefreq = atoi(argv[12]);

  // Read first line
  string word;
  getline(fileinput,word);
  cout << word << endl;
  word = word.substr(18,10);
  int np;
  np = atoi(word.c_str());
  int npout = np;
  int npin = 1;
  if((Npout>0) && (Npout<=np)) npout=Npout;
  if((Npin>0) && (Npin<=np)) npin=Npin;
  std::cout << "Outputing from " << npin << " to " << npout << " particles only" << std::endl;

  // Create variables
  int step = 0;
  int skip = -1;
  double dx = lx / mx;
  double dy = ly / my;
  double t;
  double inverse_volume_cell = 1.0 / (dx * dy);
  double x[np], y[np], z[np], y_init[np];  
  double *c, *density, *y_av; 
  c = new double [mx*my * 2]; // First half is green, second half is red
  density = new double [mx*my]; 
  y_av = new double [mx*my]; 
 
  // Initialize HydroGrid
  callHydroGrid(0,
                outputname,
                c,
                density,
                y_av,
                mx,
                my,
                lx,
                ly,
                dt,
                sample,
                step);

  // Loop over steps
  while((fileinput >> t) and (step<nsteps)){
    for(int i=0;i<np;i++){
      fileinput >> x[i] >> y[i] >> z[i];
        y[i] = y[i] - (int(y[i]/ly + 0.5*((y[i]>0)-(y[i]<0)))) * ly;
      if(step==0) y_init[i]=y[i]; // Save the initial coordinate
    }
    if(step>skip and ((step % sample) == 0)){
      std::cout << "Time t=" << t << " step=" << step << std::endl;
      // Set concentration to zero
      for(int i=0; i < mx*my; i++){
        c[i] = 0;
        c[mx*my+i] = 0;
        density[i] = 0;
        y_av[i] = 0;
      }

      // Loop over particles and save as concentration
      for(int i=npin-1;i<npout;i++){
        x[i] = x[i] - (int(x[i]/lx + 0.5*((x[i]>0)-(x[i]<0)))) * lx;
        y[i] = y[i] - (int(y[i]/ly + 0.5*((y[i]>0)-(y[i]<0)))) * ly;
	  
        int jx   = int(x[i] / dx + 0.5*mx) % mx;
        int jy   = int(y[i] / dy + 0.5*my) % my;
        int icel = jx + jy * mx;
        // Is particle green or red
        if((y_init[i] < -ly * ly_green_fraction) or (y_init[i] > ly * ly_green_fraction)){ // Particle is red
          c[mx*my+icel] += 1.0;
        }
        else{ // Particle is green
          c[icel] += 1.0;
        }
        density[icel] += 1.0;
        y_av[icel] += y_init[i];
      }
          
      for(int i=0; i < mx*my; i++){
        if(c[i]>0) {
          y_av[i] = y_av[i] / density[i]; // Average initial y coordinate for particles in this cell
        } else {
          y_av[i] = - (ly/2 + dy); // No particles in this cell so no information
        }   
        density[i] = inverse_volume_cell*density[i];
        c[i]       = inverse_volume_cell*c[i];
        c[mx*my+i] = inverse_volume_cell*c[mx*my+i];
      }
      // Call HydroGrid to update data
      callHydroGrid(1,
                    outputname,
                    c,
                    density,
                    y_av,
                    mx,
                    my,
                    lx,
                    ly,
                    dt,
                    sample,
                    step);  
      // Call Hydrogrid to print data
      if((step % savefreq == 0) and (savefreq > 0)){
        callHydroGrid(3,
                      outputname,
                      c,
                      density,
                      y_av,
                      mx,
                      my,
                      lx,
                      ly,
                      dt,
                      sample,
                      step);  
      }
    }
    step++;
  }
  

  // Free HydroGrid
  callHydroGrid(2,
                outputname,
                c,
                density,
                y_av,
                mx,
                my,
                lx,
                ly,
                dt,
                sample,
                step);

  // Free memory
  delete[] c;
  delete[] density;
  delete[] y_av;
}
