/*
  This program comuptes the 1D-concentration from the particle positions.

  HOW TO COMPILE:
  g++ -o concentration1D.exe concentration1D.cpp

  HOW TO USE:
  concentrationVTK.exe run.particles outputname lx ly num_bins var [nsteps]

  with
  run.particles = file with the particles positions generated by fluam
  lx = system's length along the x-axis
  ly = system's length along the y-axis
  num_bins = number of cells (bins) to compute the concentration
  var = 0 -> compute c(x), 1 -> compute c(y)
  nsteps = (default 1000000) How many configurations to read from the file.
           If nsteps >= total_number_of_steps the code uses all the steps.
  
 */
#include <stdlib.h> 
#include <sstream>
#include <iostream>
#include <fstream>
using namespace std;


int main(int argc, char* argv[]){
  // Input options
  ifstream fileinput(argv[1]);
  double lx = atof(argv[2]);
  double ly = atof(argv[3]);
  int num_bins = atoi(argv[4]);
  int var = atoi(argv[5]);
  int nsteps = 1000000;
  if(argc > 6) nsteps = atoi(argv[6]);


  // Create variables for histogram
  double L = var ? ly : lx;
  double width_bin = L / num_bins;
  double *histogram;
  histogram = new double[num_bins];


  // Read first line
  string word;
  getline(fileinput,word);
  word = word.substr(18,10);
  int np;
  np = atoi(word.c_str());


  // Loop over steps
  double *x, *y, *z;
  x = new double[np];
  y = new double[np];
  z = new double[np];
  double t;
  int step = 0;
  while((fileinput >> t) and (step<nsteps)){
    for(int i=0;i<np;i++){
      fileinput >> x[i] >> y[i] >> z[i];
    }
    // Loop over particles and save as 1D-concentration
    for(int i=0;i<np;i++){
      // var==0 -> c(x), else c(y)
      if(var == 0){
	y[i] = y[i] - (int(y[i]/L + 0.5*((y[i]>0)-(y[i]<0)))) * L + 0.5 * L;
	int bin = int(y[i] / width_bin);
	if(bin < num_bins){
	  histogram[bin] += 1;
	}
      }
      else{
	x[i] = x[i] - (int(x[i]/L + 0.5*((x[i]>0)-(x[i]<0)))) * L + 0.5 * L;
	int bin = int(x[i] / width_bin);
	if(bin < num_bins){
	  histogram[bin] += 1;
	}
      }
    }    
    step++;
  }


  // Normalize histogram and plot
  for(int bin=0; bin<num_bins; bin++){
    histogram[bin] /= step * width_bin;
    cout << bin*width_bin - 0.5*L << "   "  << histogram[bin] << endl;
  }

  // Free memory
  delete[] histogram;
  delete[] x;
  delete[] y;
  delete[] z;
}
